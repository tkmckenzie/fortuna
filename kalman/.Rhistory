setwd("~/projects/RDD/FirmSurvival/code")
library(shiny); source('run_shiny_app.R')
install.packages("leaflet")
source('run_shiny_app.R')
13.9861 / 147.660
setwd("~/projects/MSL/FY18/R/release_model")
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
df
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
df
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
df
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
summary(glm(Fractional.Release.G.10 ~ Breach.Area, data = df, family = binomial(link = "probit")))
summary(glm(Fractional.Release.LE.10 ~ Breach.Area, data = df, family = binomial(link = "probit")))
51.75 * 2 + 69 * 3
36 * 200
88.4 + 56.48 + 472 + 310.5 + 84.40 + 7200 + 56.48
m = lm(log(Fractional.Release.G.10) ~ log(Breach.Area), df)
summary(m)
exp(11.4351 / 1.1844)
summary(lm(log(Fractional.Release.G.10) ~ log(Breach.Area), df))
summary(lm(log(Fractional.Release.Le.10) ~ log(Breach.Area), df))
summary(lm(log(Fractional.Release.LE.10) ~ log(Breach.Area), df))
summary(glm(Fractional.Release.LE.10 ~ log(Breach.Area), data = df, family = quasibinomial(link = "probit")))
summary(glm(Fractional.Release.G.10 ~ log(Breach.Area), data = df, family = quasibinomial(link = "probit")))
sd = sqrt(1 / 0.000121)
sd
dnorm(0, 602.8, sd)
dnorm(654, 602.8, sd)
pnorm(654, 602.8, sd, upper.tail = T)
pnorm(654, 602.8, sd, lower.tail = FALSE)
pnorm(0, 602.8, sd, lower.tail = TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
exp(6.4847 / 0.8389)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
df.long
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
m.1 = lm(log(Fractional.Release) ~ 0 + Release.Size + log(Breach.Area), df)
m.1 = lm(log(Fractional.Release) ~ 0 + Release.Size + log(Breach.Area), df.long)
summary(m.1)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
summary(m.1)
m.1$coefficients
exp(-m.1$coef[1] / m.1$coef[3])
exp(-m.1$coef[2] / (m.1$coef[3] + m.1$coefficients[4]))
pnorm(2276.19, 602.8, sqrt(1 / 0.000121))
pnorm(2276.19, 602.8, sqrt(1 / 0.000121), lower.tail = FALSE)
library(dummies)
#Fit MLE
fraction.dummies = dummy(df.long$Release.Size)
#Fit MLE
fraction.dummies = dummy(df.long$Release.Size)
log.A = log(df.long$Breach.Area)
log.fr = log(df.long$Fractional.Release)
fraction.dummies
optim.result = optim(rep(0, 5), f)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
optim.result$convergence
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
exp(log.A.full)
exp(optim.result$par[3])
optim.result$par
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
source('~/projects/MSL/FY18/R/release_model/fractional_release.R', echo=TRUE)
pnorm(654.10, 602.8, sqrt(1 / 0.000121))
install.packages("SNFa")
source('~/git/Iterative_ML/R/kde_test/akj_test_mc.R', echo=TRUE)
install.packages("snow")
source('~/git/Iterative_ML/R/kde_test/akj_test_mc.R', echo=TRUE)
source('~/git/Iterative_ML/R/kde_test/akj_test_mc.R', echo=TRUE)
source('~/git/Iterative_ML/R/kde_test/akj_test_mc.R', echo=TRUE)
library(ks)
install.packages("ks")
library(ks)
eval.point = 0
d.true = dnorm(eval.point)
N.reps = 10000
library(ks)
N = 1000
eval.point = 0
x = rnorm(N)
kde(x, eval.points = eval.point)
kde(x, eval.points = c(0, 1))
source('~/git/Iterative_ML/R/kde_test/kde_test_mc.R', echo=TRUE)
library(FKF)
source('~/git/tyche/kalman/create_data.R', echo=TRUE)
source('~/git/tyche/kalman/create_data.R', echo=TRUE)
library(FKF)
matrix(c(1, 0, 0.002, 1), ncol = 2)
library(FKF)
library(ggplot2)
library(abind)
setwd("~/git/tyche/kalman")
library(dplyr)
rm(list = ls())
load("data.RData")
#Parameters
delta.t = diff(t)
delta.y = diff(y)
N = length(y)
y = y[-N]
t = t[-N]
N = length(y)
#Set up model matrices
dt = matrix(c(0, 0), ncol = 1)
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
sigma.a = 2
sigma.z = 5
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
y
dim(Tt)
Tt[,,1]
Tt[,,2]
dim(Ht)
Ht[[1]]
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]])), along = 3)
dim(HHt)
HHt[,,1]
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Zt
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
GGt
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
a0
P0
HHt
HHt[,,1]
eigen(HHt[,,1])
??dmvnorm
library(mvtnorm)
dmvnorm(rep(0, 2), rep(1, 2), HHt[,,1])
dmvnorm(rep(0, 2), rep(0, 2), HHt[,,1])
dmvnorm(rep(0, 2), rep(0, 2), HHt[,,1], log = T)
source('~/git/tyche/kalman/create_data.R', echo=TRUE)
source('~/git/tyche/kalman/kalman_fit.R', echo=TRUE)
#Set up model matrices
dt = matrix(c(0, 0), ncol = 1)
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]])), along = 3)
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
HHt[,,1]
eigen(HHt[,,1])
rm(list = ls())
load("data.RData")
#Parameters
delta.t = diff(t)
delta.y = diff(y)
N = length(y)
y = y[-N]
t = t[-N]
N = length(y)
sigma.a = 2
sigma.z = 5
#Optimize over parameters
fit.kf = function(sigma.a, sigma.z){
#Set up model matrices
dt = matrix(c(0, 0), ncol = 1)
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]])), along = 3)
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
#Fit model
m = fkf(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
return(m)
}
m = fit.kf(sigma.a, sigma.z)
m$logLik
offset = 1e-8
#Optimize over parameters
fit.kf = function(sigma.a, sigma.z){
offset = 1e-8
#Set up model matrices
dt = matrix(c(0, 0), ncol = 1)
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]]) + offset * diag(2)), along = 3)
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
#Fit model
m = fkf(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
return(m)
}
m = fit.kf(sigma.a, sigma.z)
m$logLik
dim(m$att)
m$att[,1]
m$att[,2]
m$att[,5]
source('~/git/tyche/kalman/kalman_fit.R', echo=TRUE)
sigma.a
sigma.z
fit.kf(sigma.a, sigma.z)$log_lik
fit.kf(sigma.a, sigma.z)$logLik
sigma.a = 2
sigma.z = 5
source('~/git/tyche/kalman/kalman_fit.R', echo=TRUE)
m$logLik
1E-8
source('~/git/tyche/kalman/kalman_fit.R', echo=TRUE)
#Set up model matrices
dt = matrix(c(0, 0), ncol = 1)
Tt = abind(lapply(1:N, function(i) matrix(c(1, 0, delta.t[i], 1), ncol = 2)), along = 3)
Ht = lapply(1:N, function(i) matrix(c(0.5 * delta.t[i]^2, delta.t[i]), ncol = 1) * sigma.a)
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]]) + offset * diag(2)), along = 3)
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]]) + offset * diag(2)), along = 3)
offset = 1e-8
HHt = abind(lapply(1:N, function(i) Ht[[i]] %*% t(Ht[[i]]) + offset * diag(2)), along = 3)
ct = matrix(0)
Zt = matrix(c(1, 0), ncol = 2)
Gt = matrix(1) * sigma.z
GGt = Gt %*% t(Gt)
yt = matrix(y, nrow = 1)
a0 = c(y[1], 0)
P0 = 100 * diag(2)
HHt[,,1]
Tt[,,1]
Zt = matrix(c(1, 0), ncol = 2)
Zt
Ggt
GGt
yt[1]
a0
P0
m$att
m$att[1,
]
m$logLik
v = sapply(1:N, function(i) y[i] - Tt[,,i] %*% m$att[,i])
v
Zt
v = sapply(1:N, function(i) y[i] - Zt %*% m$att[,i])
v
GGt
sum(rnorm(v, 0, sd = 5))
sum(rnorm(v, 0, sd = 5, log = TRUE))
sum(dnorm(v, 0, sd = 5, log = TRUE))
w = lapply(1:N, function(i) m$att - m$at)
w = lapply(1:N, function(i) m$att[,i] - m$at[,i])
dim(m$att)
dim(m$at)
w = lapply(1:N, function(i) m$att[,i] - m$at[,i])
sum(sapply(1:N, function(i) dmvnorm(w[[i]], c(0, 0), HHt)))
w[[1]]
sum(sapply(1:N, function(i) dmvnorm(w[[i]], c(0, 0), HHt[,,i])))
w = lapply(1:N, function(i) m$att[,i] - m$at[,i+1])
sum(sapply(1:N, function(i) dmvnorm(w[[i]], c(0, 0), HHt[,,i])))
w = lapply(1:N, function(i) m$att[,i] - m$at[,i])
sum(sapply(1:N, function(i) dmvnorm(w[[i]], c(0, 0), HHt[,,i], log = TRUE)))
w = lapply(1:N, function(i) m$att[,i] - m$at[,i+1])
sum(sapply(1:N, function(i) dmvnorm(w[[i]], c(0, 0), HHt[,,i], log = TRUE)))
dmvnorm(a0, a0, P0, log = TURE)
dmvnorm(a0, a0, P0, log = TRUE)
m$logLik
sapply(2:sample.iter, function(i) dmvnorm(m$att[,i] - Tt %*% m$att[,i-1], rep(0, 2), HHt[,,i], log = TRUE))
sapply(2:N, function(i) dmvnorm(m$att[,i] - Tt %*% m$att[,i-1], rep(0, 2), HHt[,,i], log = TRUE))
Tt
sapply(2:N, function(i) dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], rep(0, 2), HHt[,,i], log = TRUE))
m$att[,1]
Tt[,,1]
Tt[,,1] %*% m$att[,1]
i = 2
m$att[,i] - Tt[,,i] %*% m$att[,i-1]
HHt[,,1]
rep(0, 2)
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], rep(0, 2), HHt[,,i])
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], c(0, 0), HHt[,,i])
HHt[,,i]
m$att[,i] - Tt[,,i] %*% m$att[,i-1]
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], matrix(0, nrow = 2, ncol = 1), HHt[,,i])
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], c(0, 0), HHt[,,i])
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], c(0, 0), sigma = HHt[,,i])
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], mean c(0, 0), sigma = HHt[,,i])
dmvnorm(m$att[,i] - Tt[,,i] %*% m$att[,i-1], mean = c(0, 0), sigma = HHt[,,i])
HHt[,,i] %*% c(0, 0)
dmvnorm(c(m$att[,i] - Tt[,,i] %*% m$att[,i-1]), mean = c(0, 0), sigma = HHt[,,i])
dmvnorm(c(m$att[,i] - Tt[,,i] %*% m$att[,i-1]), mean = c(0, 0), sigma = HHt[,,i], log = TRUE)
dim(Tt)
Q = matrix(c(1.04102037, 2.0612203, 2.0612203, 4.08121621), nrow = 2)
Q
x = c(0.16865593, 0.11497793)
m = c(0, 0)
dmvnorm(x, m, Q, log = TRUE)
x
m
x = c(0, 0)
dmvnorm(x, m, Q, log = TRUE)
dnorm(0.168, sd = 1, log = TRUe)
dnorm(0.168, sd = 1, log = TRUE)
sqrt(det(2 * pi * Q))
log(sqrt(det(2 * pi * Q)))
-0.5 * t(x - m) %*% solve(Q) %*% (x - m)
x
x = c(0.16865593, 0.11497793)
-0.5 * t(x - m) %*% solve(Q) %*% (x - m)
solve(Q)
x - m
a0
dmvnorm(a0, rep(0, 2), P0, log = TRUE)
