#Run model:
m.e = allocative.efficiency(X, y, X.price, y.price, method = "mc", model = "br", H.inv = NA, H.mult = 1)
m.e$gradient.fit / gradient
apply(m.e$gradient.fit / gradient, 2, mean)
log.overallocation = log(price.ratio) - log(gradient)
apply(log.overallocation, 2, mean)
#Calculate mean overallocation
price.ratio = cbind(w.K / p, w.L / p)
gradient = cbind(dY.dK, dY.dL)
log.overallocation = log(price.ratio) - log(gradient)
apply(log.overallocation, 2, mean)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
#Data
K = runif(N, 25, 50)
L = runif(N, 10, 30)
efficiency = exp(-abs(rnorm(N, sd = 0.1)))
# efficiency = 1
Y = A * K^beta.K * L^beta.L * efficiency
dY.dK = A * beta.K * K^(beta.K - 1) * L^beta.L * efficiency
dY.dL = A * beta.L * K^beta.K * L^(beta.L - 1) * efficiency
p = rnorm(N, mean = 10, sd = 1)
dR.dK = p * dY.dK
dR.dL = p * dY.dL
w.K.star = p * dY.dK
w.L.star = p * dY.dL
w.K = w.K.star * exp(w.K.bias)
w.L = w.L.star * exp(w.L.bias)
#Calculate mean overallocation
price.ratio = cbind(w.K / p, w.L / p)
gradient = cbind(dY.dK, dY.dL)
log.overallocation = log(price.ratio) - log(gradient)
apply(log.overallocation, 2, mean)
X
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
source('~/code/R/smoothing/npbr_test/snfa_quantity.R', echo=TRUE)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
1 / exp(1)
log(1 / exp(1))
log(1 / (log(4)))
gradient / m.e$gradient.fit
gradient / (m.e$gradient.fit * m.e$technical.efficiency)
apply(gradient / (m.e$gradient.fit * m.e$technical.efficiency), 2, mean)
gradient
efficiency
gradient / efficiency
0.8316379 / 0.9628091
0.8232811 / 0.9628091
0.8239839 / 0.9807970
apply((gradient / efficiency) / m.e$gradient.fit, 2, mean)
apply(apply(gradient, 2, function(col) col / efficiency) / m.e$gradient.fit, 2, mean)
apply(gradient / apply(m.e$gradient.fit, 2, function(col) col * efficiency), 2, mean)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
apply(gradient.ratio, 2, meaa)
apply(gradient.ratio, 2, mean)
gradient.ratio
apply(gradient.ratio, 2, mean, na.rm = T)
apply(gradient.ratio, 2, median, na.rm = T)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
source('~/code/R/smoothing/npbr/snfa_package/snfa/R/allocative.efficiency.R', echo=TRUE)
source('~/code/R/smoothing/npbr_test/snfa_expenditure.R', echo=TRUE)
efficiency
m.e$technical.efficiency
2000*1.37
2000*2.37
8+6+9+7+7+9
8+6+9+7+7+7
?optim
5844/100
20*100 / 60
50*100 / 60
300/5844
28+18
source('~/git/fortuna/gp_envelope/2_fit_gp.R', echo=TRUE)
1927/3600
1927/60
library(abind)
library(ggplot2)
library(rstan)
setwd("~/git/fortuna/gp_envelope/")
rm(list = ls())
load("data.RData")
load("gp_fit.RData")
stan.extract = extract(stan.fit)
#Prediction functions
cov.exp.quad = function(x.1, x.2, alpha, rho){
N.1 = length(x.1)
N.2 = length(x.2)
alpha.sq = alpha^2
rho.sq = rho^2
result = matrix(NA, nrow = N.1, ncol = N.2)
for (i in 1:N.1){
for (j in 1:N.2){
result[i, j] = alpha.sq * exp(-(x.1[i] - x.2[j])^2 / (2 * rho.sq))
}
}
return(result)
}
names(stan.extract)
dim(stan.extract$log_delta)
z = apply(stan.extract$log_delta, 2, mean)
plot(z ~ x)
z = apply(exp(stan.extract$log_delta, 2, mean))
z = apply(exp(stan.extract$log_delta), 2, mean)
plot(z ~ x)
#DEBUG
i = 1
alpha = stan.extract$alpha[i]
rho = stan.extract$rho[i]
sigma = stan.extract$sigma[i]
alpha.delta = stan.extract$alpha_delta[i]
P.inv.diag.delta = stan.extract$P_inv_diag_delta[i]
P.inv.diag.delta = stan.extract$P_inv_diag_delta[,i]
P.inv.diag.delta = stan.extract$P_inv_diag_delta[i,]
log.delta = stan.extract$log_delta[i,]
#DEBUG
i = 1
alpha = stan.extract$alpha[i]
sigma = stan.extract$sigma[i]
rho = stan.extract$rho[i]
alpha.delta = stan.extract$alpha_delta[i]
P.inv.diag.delta = stan.extract$P_inv_diag_delta[i,]
sigma.delta = stan.extract$sigma_delta[i]
log.delta = stan.extract$log_delta[i,]
N.pred = 100
x.pred = seq(min(x), max(x), length.out = N.pred)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
#First generate realizations of sigma
Sigma = cov.exp.quad(x, x, alpha.delta, rho.delta) + sigma.delta^2 * diag(N)
c(1, 2, 3) * diag(3)
#Prediction functions
cov.exp.quad = function(x.1, x.2, alpha, P.inv.diag){
N.1 = length(x.1)
N.2 = length(x.2)
alpha.sq = alpha^2
P.inv = P.inv.diag * diag(length(P.inv.diag))
result = matrix(NA, nrow = N.1, ncol = N.2)
for (i in 1:N.1){
for (j in 1:N.2){
x.1.minus.x.2 = x.1 - x.2
result[i, j] = alpha.sq * exp(-(x.1[i] - x.2[j])^2 / (2 * rho.sq))
}
}
return(result)
}
z = c(1, 2, 3)
t(z)
#Prediction functions
cov.exp.quad = function(x.1, x.2, alpha, P.inv.diag){
N.1 = length(x.1)
N.2 = length(x.2)
alpha.sq = alpha^2
P.inv = P.inv.diag * diag(length(P.inv.diag))
result = matrix(NA, nrow = N.1, ncol = N.2)
for (i in 1:N.1){
for (j in 1:N.2){
x.1.minus.x.2 = matrix(x.1 - x.2, ncol = 1)
result[i, j] = alpha.sq * exp(-0.5 * t(x.1.minus.x.2) %*% P.inv %*% x.1.minus.x.2)
}
}
return(result)
}
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
#First generate realizations of sigma
Sigma = cov.exp.quad(x, x, alpha.delta, rho.delta) + sigma.delta^2 * diag(N)
#First generate realizations of sigma
Sigma = cov.exp.quad(x, x, alpha.delta, P.inv.diag.delta) + sigma.delta^2 * diag(N)
x.1 = x
x.2 = x
N.1 = length(x.1)
N.2 = length(x.2)
alpha.sq = alpha^2
P.inv = P.inv.diag * diag(length(P.inv.diag))
P.inv.diag = P.inv.diag.delta
P.inv = P.inv.diag * diag(length(P.inv.diag))
P.inv
x1
x.1
nrow(x.1)
matrix(x.1, ncol = ncol(x.1))
is.matrix(x.1)
#Prediction functions
cov.exp.quad = function(x.1, x.2, alpha, P.inv.diag){
if (!is.matrix(x.1)){
x.1 = matrix(x.1, ncol = 1)
}
if (!is.matrix(x.2)){
x.2 = matrix(x.2, ncol = 1)
}
N.1 = nrow(x.1)
N.2 = nrow(x.2)
alpha.sq = alpha^2
P.inv = P.inv.diag * diag(length(P.inv.diag))
result = matrix(NA, nrow = N.1, ncol = N.2)
for (i in 1:N.1){
for (j in 1:N.2){
x.1.minus.x.2 = matrix(x.1 - x.2, ncol = 1)
result[i, j] = alpha.sq * exp(-0.5 * t(x.1.minus.x.2) %*% P.inv %*% x.1.minus.x.2)
}
}
return(result)
}
#Prediction functions
cov.exp.quad = function(x.1, x.2, alpha, P.inv.diag){
if (!is.matrix(x.1)){
x.1 = matrix(x.1, ncol = 1)
}
if (!is.matrix(x.2)){
x.2 = matrix(x.2, ncol = 1)
}
N.1 = nrow(x.1)
N.2 = nrow(x.2)
alpha.sq = alpha^2
P.inv = P.inv.diag * diag(length(P.inv.diag))
result = matrix(NA, nrow = N.1, ncol = N.2)
for (i in 1:N.1){
for (j in 1:N.2){
x.1.minus.x.2 = matrix(x.1[i,] - x.2[j,], ncol = 1)
result[i, j] = alpha.sq * exp(-0.5 * t(x.1.minus.x.2) %*% P.inv %*% x.1.minus.x.2)
}
}
return(result)
}
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of sigma
Sigma = cov.exp.quad(x.y, x.y, alpha.delta, P.inv.diag.delta) + sigma.delta^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, log.delta))
z = y + apply(exp(stan.extract$log_delta), 2, mean)
plot(z ~ x)
plot(y ~ x)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, rho) + sigma^2 * diag(N)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, rho)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
line(f.pred ~ x)
line(f.pred.mu ~ x)
lines(f.pred.mu ~ x)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
lines(f.pred.mu ~ x)
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
x = sort(x)
lines(f.pred.mu ~ x)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
points(f.pred.mu ~ x)
points(f.pred.mu ~ x, type = "l")
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y + log.delta))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
points(f.pred.mu ~ x, type = "l")
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y + exp(log.delta)))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
points(f.pred.mu ~ x, type = "l")
lines(f.pred.mu ~ x)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y + exp(log.delta)))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
f.pred.mu = f.pred.mu[order(x)]
x = sort(x)
lines(f.pred.mu ~ x)
source('~/git/fortuna/gp/3_post - Copy.R', echo=TRUE)
warnings()
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/3_post - Copy.R', echo=TRUE)
alpha = mean(stan.extract$alpha)
sigma = mean(stan.extract$sigma)
rho = mean(stan.extract$rho)
N.pred = 100
x.pred = seq(min(x), max(x), length.out = N.pred)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, 1 / rho^2) - t(v.pred) %*% v.pred
result = cbind(f.pred.mu, diag(cov.f.pred) + sigma^2) #Unconditional variance of y
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
x = sort(x)
lines(f.pred.mu ~ x)
source('~/git/fortuna/gp/3_post - Copy.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, 1 / rho^2) - t(v.pred) %*% v.pred
result = cbind(f.pred.mu, diag(cov.f.pred) + sigma^2) #Unconditional variance of y
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
x = sort(x)
lines(f.pred.mu ~ x)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y + exp(log.delta)))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
lines(f.pred.mu ~ x.pred)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
plot(y ~ x)
lines(f.pred.mu ~ x.pred)
library(MASS)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, rho) - t(v.pred) %*% v.pred
y.pred = mvrnorm(1, f.pred.mu, diag(cov.f.pred) + sigma^2)
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, rho) - t(v.pred) %*% v.pred
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, 1 / rho^2) - t(v.pred) %*% v.pred
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
y.pred = f.pred.mu
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
plot(y ~ x)
f.pred.mu = f.pred.mu[order(x)]
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, 1 / rho^2) - t(v.pred) %*% v.pred
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
y.pred = f.pred.mu
plot(y ~ x)
lines(y.pred ~ x.pred)
#Now generate realizations of delta
x.pred.y.pred = cbind(x.pred, y.pred)
Sigma = cov.exp.quad(x.y, x.y, alpha.delta, P.inv.diag.delta) + sigma.delta^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, log.delta))
K.x.x.pred = cov.exp.quad(x.y, x.pred.y.pred, alpha.sigma, rho.sigma)
K.x.x.pred = cov.exp.quad(x.y, x.pred.y.pred, alpha.delta, rho.delta)
K.x.x.pred = cov.exp.quad(x.y, x.pred.y.pred, alpha.delta, P.inv.diag.delta)
log.sigma.pred.mu = t(K.x.x.pred) %*% K.div.y
log.delta.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred.y.pred, x.pred.y.pred, alpha.delta, P.inv.diag.delta) - t(v.pred) %*% v.pred
delta.pred = mvrnorm(1, log.delta.pred.mu, cov.f.pred + sigma.delta^2 * diag(N.pred))
lines(delta.pred ~ x.pred)
lines(I(y.pred + delta.pred) ~ x.pred)
delta.pred = exp(mvrnorm(1, log.delta.pred.mu, cov.f.pred + sigma.delta^2 * diag(N.pred)))
plot(y ~ x)
lines(y.pred ~ x.pred)
lines(I(y.pred + delta.pred) ~ x.pred)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
#This returns predicted f mean (col 1) and variance (col 2)
N.pred = length(x.pred)
N = length(y)
x.y = cbind(x, y)
#First generate realizations of y
Sigma = cov.exp.quad(x, x, alpha, 1 / rho^2) + sigma^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.x.x.pred = cov.exp.quad(x, x.pred, alpha, 1 / rho^2)
K.div.y = solve(t(L.Sigma), solve(L.Sigma, y))
f.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred, x.pred, alpha, 1 / rho^2) - t(v.pred) %*% v.pred
y.pred = mvrnorm(1, f.pred.mu, cov.f.pred + sigma^2 * diag(N.pred))
y.pred = f.pred.mu
#Now generate realizations of delta
x.pred.y.pred = cbind(x.pred, y.pred)
Sigma = cov.exp.quad(x.y, x.y, alpha.delta, P.inv.diag.delta) + sigma.delta^2 * diag(N)
L.Sigma = t(chol(Sigma))
K.div.y = solve(t(L.Sigma), solve(L.Sigma, log.delta))
K.x.x.pred = cov.exp.quad(x.y, x.pred.y.pred, alpha.delta, P.inv.diag.delta)
log.delta.pred.mu = t(K.x.x.pred) %*% K.div.y
v.pred = solve(L.Sigma, K.x.x.pred)
cov.f.pred = cov.exp.quad(x.pred.y.pred, x.pred.y.pred, alpha.delta, P.inv.diag.delta) - t(v.pred) %*% v.pred
delta.pred = exp(mvrnorm(1, log.delta.pred.mu, cov.f.pred + sigma.delta^2 * diag(N.pred)))
delta.pred = exp(log.delta.pred.mu)
plot(y ~ x)
lines(y.pred ~ x.pred)
lines(I(y.pred + delta.pred) ~ x.pred)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
apply(stan.extract$log_delta, 2, mean)
source('~/git/fortuna/gp/1_create_data.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp/3_post.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/2_fit_gp.R', echo=TRUE)
rm(list = ls())
source('~/git/fortuna/gp_envelope/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/2_fit_gp.R', echo=TRUE)
source('~/git/fortuna/gp_envelope/3_post.R', echo=TRUE)
plot(y ~ x)
points(y + apply(exp(stan.extract$log_delta), 2, mean), color = "red")
plot(y ~ x)
points(I(y + apply(exp(stan.extract$log_delta), 2, mean)) ~ x, col\ = "red")
points(I(y + apply(exp(stan.extract$log_delta), 2, mean)) ~ x, col = "red")
ggplot(point.df, aes(x, y)) +
geom_point() +
geom_line(data = fit.df, aes(color = variable)) +
theme_bw()
